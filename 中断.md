#中断分类
##硬件中断
-  可屏蔽中断: 可通过CPU或中断控制器屏蔽控制器来屏蔽的中断
-  非可屏蔽中断    


##软件中断
-  软件中断: 通过软件指令生成的中断, 与硬件中断相比, 软件中断为同步的方式.表现为CPU指令集中的一条指令, 通常用于陷入内核态中.

#CPU的角度看中断
##硬件
CPU上有一个或多个引脚,这些引脚通过状态触发或边沿触发, 感知是否有中断发生. 不同的引脚可以分类为可屏蔽中断或屏蔽中断. CPU内部的寄存器, 也可以设置屏蔽位.   

-  状态触发: 维持在引脚线上维持高电平,通知cpu有中断发生, 直到cpu进行了中断处理,才将电平复位.
-  边沿触发: 发送一个脉冲至cpu,通知cpu有中断发生, 这类中断容易丢失, 可以通过使用一个锁存器保寸历史中断.   

##软件
CPU每次执行一个指令前, 都会根据CPU引脚判断是否有中断发生.如果有中断发生,则不是取下一条指令,而是执行中断处理.中断处理首先保存当前执行现场, 然后通过中断向量找到对应的中断矢量表, 根据中断矢量表中设定的中断服务程序地址, 载入中断处理程序, 运行完成后, 恢复现场, 继续之前的处理.
###中断处理过程   

在实际运行中，一旦设备通过某引脚N向8259A发出中断指令，后者便向8086A的INTR引脚发送中断信号。8086A通过INTA引脚通知8259A中断有效（这个过程实际上还包括对此8259A的选址），后者即通过地址总线将对应引脚N的中断类型码（已预先存好，见上节）发送给CPU。CPU得到中断类型码后，先进行现场保护，主要包括：

状态寄存器FLAGS压栈（同时堆栈寄存器SP-2）；
关闭中断（将FLAGS寄存器的IF位置零）；
将当前代码段寄存器CS和程序计数器IP压栈（同时堆栈寄存器SP-4）。
现场保护完成后，CPU开始按照前述的两步骤翻译中断程序入口地址。在得到中断处理程序地址之后但调用中断处理程序之前，CPU会再检查一下NMI引脚是否有信号，以防在刚才的处理过程中忽略了可能的NMI中断。NMI的优先级始终高于INTR。

中断处理程序虽然是由程序员编写，但须循一定规范。作为例程，中断处理程序应该先将各寄存器信息（除了IP和CS，此二寄存器现已指向当前中断程序）压入堆栈予以保存，这样才能在中断处理程序内部使用这些寄存器。在程序结束时，应该按与压栈保护时相反的顺序弹出各寄存器的值。中断程序的最后一句始终是IRET指令，这条指令将栈顶6个字节分别弹出并存入IP、CS和FLAGS寄存器，完成了现场的还原。

#外设的角度看中断
外设在硬件上表现为数据缓冲区, 控制器, 物理部分, DMA. 软件上包括cpu指令, cpu内核驱动程序.
##硬件
一个外设, 有一个控制器, 控制器接收cpu过来的指令,对外设进行相应操作.还有数据缓冲区, 相应的数据放在缓冲区中,在需要时传送到内核内存区或用户内存中.
为了将CPU从内存和数据缓冲区的数据复制工作中解放开来, 出现了DMA.
##软件
CPU操作外设的指令. 指令中对控制器上寄存器的抽象, 可以直接通过内存访问, 也可以采用专用的通道.   

CPU发起一个外设操作,即是发送指令.然后, CPU可以      
-   轮询
-   去忙其他的事情, 等待中断